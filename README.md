# PtaaS: Asynchronous Password Audit Platform

## Description

This project is a web-based platform designed to perform offline password security audits. It allows users to upload files containing password hashes and simulate various cracking attacks in a controlled environment. The platform utilizes an asynchronous architecture to handle potentially long-running audit tasks without blocking the user interface and provides detailed graphical reports analyzing the results.

## Features

* **Multiple Hash Types Supported**: Audits hashes for MD5, SHA-256, PBKDF2, bcrypt, and Argon2.
* **Multiple Attack Modes**:
    * **Dictionary Attack**: Uses a wordlist combined with common rule-based transformations (e.g., capitalization, suffixes, simple leetspeak) generated by the `apply_rules` function.
    * **Mask Attack**: Performs targeted brute-force based on user-defined patterns (e.g., `?u?l?l?d?s`) using the `mask_generator` function.
    * **Advanced Rule ("AI") Attack**: Generates targeted candidates based on a provided company name using a complex set of heuristic rules (`generate_candidates` function).
* **Asynchronous Job Processing**: Leverages Celery and Redis to run audits in the background, ensuring the Flask web application remains responsive.
* **Persistent Job History**: Uses MongoDB to store details and results of all submitted audit jobs, accessible via a dashboard.
* **Graphical Reporting**: Displays detailed audit results with interactive charts (using Chart.js) for performance benchmarks, vulnerability classifications, password entropy distribution, and policy compliance failures.
* **Security Analysis**: Calculates metrics like Shannon entropy, checks against basic password policies, assigns an overall security grade, and identifies common weakness patterns.
* **Password Strength Checker**: Includes a separate utility page to quickly analyze the strength of an individual password based on entropy and estimated cracking time.
* **Dark Mode**: Features a theme toggle for user preference.

## Technologies Used

* **Backend**: Python 3, Flask
* **Task Queue**: Celery
* **Message Broker / Result Backend**: Redis
* **Database**: MongoDB (using PyMongo driver)
* **Concurrency (Worker on Windows)**: Eventlet
* **Hashing Libraries**: hashlib, bcrypt, argon2-cffi
* **Frontend**: HTML5, CSS3, JavaScript
* **Charting**: Chart.js
* **Development Environment**: Windows 11 with WSL (Ubuntu) for Redis

## Setup and Installation

### Prerequisites

1.  **Python**: Version 3.9 or higher recommended.
2.  **Redis**: A running Redis server. For Windows development, installation via WSL is recommended.
    * Install WSL: `wsl --install` (in Admin PowerShell)
    * Install Redis in WSL (Ubuntu): `sudo apt update && sudo apt install redis-server`
3.  **MongoDB**: A running MongoDB server. Can be installed directly on Windows (recommended for this setup) or via WSL.
    * Follow the official MongoDB Community Server installation guide for Windows. Ensure it's installed as a service.

### Installation Steps

1.  **Clone the Repository** (or download the source code):
    ```bash
    git clone [Your Repository URL]
    cd [Your Project Folder, e.g., Ptaas]
    ```
2.  **Create and Activate Virtual Environment**:
    ```powershell
    # In PowerShell, in your project folder
    python -m venv myenv
    .\myenv\Scripts\activate
    ```
3.  **Install Dependencies**:
    ```powershell
    pip install -r requirements.txt
    ```
4.  **Configure Redis Connection**:
    * Start Redis in your WSL terminal: `sudo service redis-server start`
    * Find your WSL IP address: `hostname -I` (in WSL terminal)
    * Edit the `celery_config.py` file and replace `localhost` or the placeholder IP with your current WSL IP address in both `broker_url` and `result_backend`.
    * *Note: If Redis was configured differently (e.g., requires password, different port), update `celery_config.py` accordingly.*
5.  **Configure MongoDB Connection**:
    * Ensure your MongoDB server is running (check Windows Services if installed directly).
    * The connection string in `app.py` and `tasks.py` currently points to `mongodb://127.0.0.1:27017/`. This should work for a default Windows installation. If MongoDB is running elsewhere (like WSL), update this string accordingly.

## Running the Application

You need to run three separate processes in three different terminals:

1.  **Terminal 1: Redis Server (WSL - Ubuntu)**
    * Ensure Redis is running:
        ```bash
        sudo service redis-server start
        # Verify with: redis-cli ping (should return PONG)
        ```

2.  **Terminal 2: Celery Worker (PowerShell - with venv active)**
    * Navigate to your project directory (`D:\Ptaas`).
    * Make sure your virtual environment (`myenv`) is activated.
    * Run the worker script:
        ```powershell
        python run_worker.py
        ```
    * You should see the worker connect to Redis and report ready status.

3.  **Terminal 3: Flask Web Server (PowerShell - with venv active)**
    * Navigate to your project directory (`D:\Ptaas`).
    * Make sure your virtual environment (`myenv`) is activated.
    * Run the Flask application:
        ```powershell
        flask run
        ```
    * Access the application in your web browser, typically at `http://127.0.0.1:5000`.

## Usage

1.  Navigate to the main page (`/`).
2.  Use the "Check Password Strength" link (`/strength_checker`) for individual password analysis.
3.  On the main page, upload a JSON file containing password hashes (see `user_hashes.json` for example format).
4.  Enter an optional Company Name for analysis.
5.  Select an Attack Mode (Dictionary, Mask, AI) and provide the required inputs (Wordlist path - currently defaults to `wordlist.txt`, Mask pattern, AI intensity).
6.  Click "Start Audit". You will be redirected to the job status page (`/job/<task_id>`).
7.  The status page will auto-refresh until the job is complete (`SUCCESS` or `FAILURE`).
8.  View the detailed graphical report on the status page upon successful completion.
9.  Use the "View Job History" link (`/dashboard`) to see a list of all past audits stored in MongoDB.

## Security Considerations (for Lab Environment)

* This project is a proof-of-concept and does **not** implement production-level security.
* There is no user authentication; the platform is currently public.
* Cracked passwords and results are stored unencrypted in MongoDB.
* Input validation is minimal.
* A real-world deployment would require significant hardening, including user accounts, access control, encryption at rest, data retention policies, input sanitization, and rate limiting.
